\subsection{States, messages, representatives}

The full-node protocol states are {\em sets} of messages,
each message being a triple $(c, v, j)$, where:
\begin{itemize}
    \item $c$ is a (proposed) consensus value
    \item $v$ identifies the sender of the message
    \item $j$, the justification, {\em is the protocol state} in which the sender
        was at the time the message was sent
\end{itemize}

There are two technical difficulties with the above definition:  
\begin{itemize}
    \item It is recursive (states are sets of messages, each containing a state)
    \item The ordering of the message should not matter
\end{itemize}

To solve the first issue, we chose to postpone the definition of messages and
to define states inductively as follows:

\begin{coq}
Inductive state : Type :=
  | Empty : state
  | Next : C ->  V -> state -> state -> state.
\end{coq}

This definition says that a state can be build by extending an existing state
given a consensus value (C), a validator (V), and another state representing
the justification.
To clarify that the three are the components of a message, we introduce the
following notation for \verb"Next":

\begin{coq}
Notation "'add' ( c , v , j ) 'to' sigma" :=
  (Next c v j sigma)
  (at level 20).
\end{coq}

This definitions addresses the first issue mentioned above, that is, the 
recursive nature of states.

The second issue is very important as it relates to the notion of
state equality.
Although it is pottentially possible to define an equivalence between
states which disregards the order between messages, that is definitely
not trivial, because it is itself recursive, as it requires an equivalence
on messages, which must be defined in terms of the same state equivalence.
This would be a hinderance to both define it and work with it.

Our approach was to work with canonical representatives of these classes,
namely what we called LocallySorted states.  Although this definition
is still recursive, it's easier to express and to work with it than with the
equivalence one because it is only defined in terms of a single state.

To define the notion of sorted states, we need to be able to compare messages,
which amounts to defining a (total) order relation on states.
This can be defined as a lexicographic ordering on the state seen as a list
of messages, with the tweak of recursing in order to compare justifications:

\begin{coq}
Fixpoint state_compare (sigma1 sigma2 : state) : comparison :=
  match sigma1, sigma2 with
  | Empty, Empty => Eq
  | Empty, _ => Lt
  | _, Empty => Gt
  | add (c1, v1, j1) to sigma1, add (c2, v2, j2) to sigma2 =>
    match compare c1 c2 with
    | Eq =>
      match compare v1 v2 with
      | Eq =>
        match state_compare j1 j2 with
        | Eq => state_compare sigma1 sigma2
        | cmp_j => cmp_j
        end
      | cmp_v => cmp_v
      end
    | cmp_c => cmp_c
    end
  end.
\end{coq}

Note that defining this ordering requires a existing orderings on
consensus values and validators, but these can any orderings,
and an total ordering is guaranteed to exists for any set in set theory
including axiom of choice \cite{Gonzalez}.
    
This ordering naturally induces an ordering on messages, and thus allows us
to define the notion of a \verb"LocallySorted" state, i.e., one in which
each message is smaller than the next and all justifications are themselves
\verb"LocallySorted".

\verb"LocallySorted" states are chosen as representatives for states, with the
benefit that testing equality of such states reduces to checking syntactic
equality.

Protocol states are defined by means of an inductive predicate on states, by

\begin{coq}
(* Valid protocol state definition *) 
Inductive protocol_state : state -> Prop :=
  | protocol_state_empty : protocol_state Empty
  | protocol_state_next
         : forall s j
         , protocol_state s
        -> protocol_state j
        -> incl_messages j s
        -> forall c v
         , valid_estimate c j
        -> not_heavy (add_in_sorted_fn (c,v,j) s)
        -> protocol_state (add_in_sorted_fn (c,v,j) s).
\end{coq}

The above definition reads as:
\begin{itemize}
    \item a protocol state is either empty; or
    \item it can be obtained from an existing protocol state $s$ by extending
        it with a message $(c, v, j)$ such that:
        \begin{itemize}
            \item $j$ is a protocol state included in $s$
            \item $c$ is a consensus values which can be estimated by $j$
            \item adding $(c,v,j)$ to $s$ does not produce a heavy state
        \end{itemize}
\end{itemize}

